# Claude Code Rules for YAML Custom Fields Plugin

## Coding Standards

### 1. NO phpcs:ignore Comments
**NEVER** use `phpcs:ignore` or `phpcs:disable` comments to suppress WordPress Coding Standards warnings or errors.

**Why:**
- Suppressions hide real problems
- They make code reviews harder
- WordPress.org reviewers flag excessive suppressions
- Proper fixes are always better than suppressions

**Instead:**
- Fix the actual issue
- Refactor the code to comply with standards
- If it's a false positive in test files, document why the code is correct as-is
- For legitimate exceptions (like test mocks), use `phpcs.xml.dist` configuration exclusions instead of inline comments

### 2. WordPress Coding Standards Compliance
All code must follow WordPress Coding Standards without exceptions:
- Prefix all global variables with `yaml_cf_`
- Use WordPress functions instead of PHP functions where available
- Validate and sanitize all input
- Escape all output (see rule 3b for details)
- Use nonces for all forms and AJAX requests

### 3. Security First
- Never use `eval()`, `base64_decode()` for code execution
- Always validate file uploads with MIME type checking
- Use `isset()` before accessing array indices
- Sanitize user input, escape output
- Use prepared statements for all database queries

### 3a. ALWAYS Sanitize Input Fields
**Every single input** from users, URLs, forms, or AJAX must be sanitized.

### 3b. Escape ALL Output (Except Code Fields)
**Every value displayed to users must be escaped** to prevent XSS attacks.

**Escaping functions by context:**
- HTML content: `esc_html($value)`
- HTML attributes: `esc_attr($value)`
- URLs: `esc_url($url)`
- JavaScript: `esc_js($value)` or `wp_json_encode($data)`
- Rich text (with HTML): `wp_kses_post($content)`

**EXCEPTION - Code/Schema Fields:**
Code fields (YAML schemas, code snippets) should NOT be escaped when displayed in:
- `<textarea>` for editing
- `<pre><code>` blocks for display
- Syntax-highlighted code blocks

**Why:** Escaping code fields breaks syntax (converts `<` to `&lt;` making code invalid).

**Safe code display:**
```php
// For editing in textarea (no escaping needed, textarea is safe)
<textarea><?php echo $yaml_schema; ?></textarea>

// For display in code blocks (escape HTML but preserve code structure)
<pre><code><?php echo htmlspecialchars($code, ENT_QUOTES, 'UTF-8'); ?></code></pre>

// For syntax highlighting (let the highlighter handle escaping)
<div class="yaml-code" data-code="<?php echo esc_attr($code); ?>"></div>
```

**Everything else MUST be escaped** - no exceptions.

**Required sanitization for common inputs:**
- Text fields: `sanitize_text_field($_POST['field'])`
- Emails: `sanitize_email($_POST['email'])`
- URLs: `esc_url_raw($_POST['url'])`
- Keys/slugs: `sanitize_key($_POST['key'])`
- File names: `sanitize_file_name($_FILES['file']['name'])`
- HTML content: `wp_kses_post($_POST['content'])` or `wp_kses($_POST['content'], $allowed_html)`

**Before accessing:**
1. Check `isset()` or `!empty()`
2. Sanitize immediately
3. Validate the sanitized value
4. Never trust user input

**Example (correct):**
```php
if (isset($_POST['title'])) {
    $title = sanitize_text_field(wp_unslash($_POST['title']));
    if (!empty($title)) {
        // Use $title
    }
}
```

### 4. Prefix All PHP Variables (Where Required)
**Global variables MUST be prefixed:**
- All global scope variables: `$yaml_cf_variable_name`
- Plugin options: `yaml_cf_option_name`
- Post meta keys: `_yaml_cf_meta_key` (leading underscore for private)
- Transients: `yaml_cf_transient_name`
- Constants: `YAML_CF_CONSTANT_NAME`

**Other naming conventions:**
- Local variables (inside functions): snake_case (no prefix needed)
- Class properties: snake_case with visibility modifiers
- Function parameters: snake_case (no prefix needed)
- Loop variables: Standard names (`$i`, `$key`, `$value`) are okay

**Why prefix globals:**
- Prevents conflicts with other plugins/themes
- WordPress.org requirement
- Makes code origin clear
- WPCS will flag unprefixed globals as errors

### 5. NO Direct SQL Writing
**NEVER** write direct SQL queries using `$wpdb->query()`, `$wpdb->get_*()`, etc.

**Why:**
- SQL injection vulnerabilities
- Bypasses WordPress data validation
- Breaks caching
- Makes code harder to maintain
- WordPress.org reviewers reject direct queries

**Instead:**
- Use WordPress data APIs: `update_post_meta()`, `get_option()`, `wp_insert_post()`, etc.
- For complex queries, use WordPress query classes: `WP_Query`, `WP_User_Query`, `WP_Meta_Query`
- Let WordPress handle the database

**The ONLY exception:**
- `uninstall.php` can use direct DELETE queries for bulk cleanup when plugin is removed
- Even then, must have proper documentation explaining why

### 6. File Structure
- One class per file
- Namespace must be first statement after `<?php`
- ABSPATH check comes after namespace declaration
- No closing `?>` tags

### 7. Testing
- All test files must follow WPCS
- Test helper methods are allowed to manipulate superglobals
- Mock functions should be simple and safe
- 100% of tests must pass before any commit
- Mock WordPress functions (in test bootstrap files) MUST use WordPress core function names exactly - they cannot be prefixed, as this would break mocking functionality. Document why these are correct.

### 8. Comments
- Use clear, concise comments
- Document WHY, not WHAT
- No TODO comments without a corresponding issue
- PHPDoc blocks for all public methods

### 9. File Upload Validation
**All file uploads MUST be validated:**
1. Check `isset($_FILES['field'])` before accessing
2. Validate `$_FILES['field']['error'] === UPLOAD_ERR_OK`
3. Check file size limits (5MB max for JSON)
4. Validate MIME type using `finfo_file()` (server-side)
5. Validate file extension with `pathinfo()`
6. Sanitize filename with `sanitize_file_name()`
7. Validate file content structure (e.g., JSON parsing)
8. Use WordPress `wp_handle_upload()` for final processing

**Never trust:**
- Client-side validation alone
- File extensions alone
- MIME types from $_FILES (can be spoofed)

### 10. Nonce Verification
**Every form submission and AJAX request MUST verify nonces:**

```php
// Forms
if (!isset($_POST['nonce']) || !wp_verify_nonce($_POST['nonce'], 'action_name')) {
    wp_die('Security check failed');
}

// AJAX
check_ajax_referer('yaml_cf_nonce', 'nonce');
```

**Create nonces:**
- In forms: `wp_nonce_field('action_name', 'nonce')`
- For AJAX: `wp_create_nonce('yaml_cf_nonce')` passed via `wp_localize_script()`

### 11. Capability Checks
**Every admin action MUST check user capabilities:**

```php
if (!current_user_can('manage_options')) {
    wp_die('Permission denied');
}

// Or for AJAX
if (!current_user_can('edit_post', $post_id)) {
    wp_send_json_error('Permission denied');
}
```

**Never assume:**
- User has permission because they're logged in
- Admin URLs are protected automatically
- AJAX is secure without capability checks

### 12. Array Access Safety
**Always check array indices exist before accessing:**

```php
// Correct
if (isset($_POST['field'])) {
    $value = sanitize_text_field($_POST['field']);
}

// Also correct
$value = isset($_POST['field']) ? sanitize_text_field($_POST['field']) : 'default';

// Wrong - will trigger WPCS warning
$value = $_POST['field']; // Undefined index warning
```

### 13. WordPress Functions Over PHP
**Use WordPress functions instead of PHP equivalents:**

- `wp_strip_all_tags()` NOT `strip_tags()`
- `wp_json_encode()` NOT `json_encode()`
- `wp_parse_args()` NOT `array_merge()` for defaults
- `wp_safe_redirect()` NOT `header('Location: ')`
- `wp_remote_get()` NOT `file_get_contents()` or `curl_*`
- `wp_cache_*()` NOT custom caching
- `update_option()` NOT direct SQL
- `update_post_meta()` NOT direct SQL

**Why:** WordPress functions handle edge cases, sanitization, and WordPress-specific concerns.

### 14. Error Handling
- Use WordPress error handling (`WP_Error`)
- Log errors in debug mode only
- Never expose paths or sensitive info
- Graceful degradation
- Return errors, don't die silently

### 15. Dependencies
- Minimize external dependencies
- All Composer packages must be scoped
- No dependencies on external APIs
- No phone-home functionality

### 16. Consistent User Feedback
**Always use the same alert pattern at the top right corner for every action.**

**Why:**
- Consistent user experience across the plugin
- Users know where to look for feedback
- Maintains professional UI/UX standards
- Prevents confusion from inconsistent messaging

**Requirements:**
- All success messages use the same alert component
- All error messages use the same alert component
- Alerts appear in the top right corner consistently
- Use the same styling and animation patterns
- Don't mix different notification methods

**Example contexts:**
- Save actions
- Delete confirmations
- Import/export operations
- AJAX responses
- Form validations

## Enforcement

These rules are enforced by:
1. WordPress Coding Standards (PHPCS)
2. PHPUnit tests (120 tests must pass)
3. Security audit scripts (`bin/security-audit.sh`)
4. Code quality checks (`bin/code-quality-check.sh`)

## Exceptions

**There are NO exceptions.** If WPCS flags something, fix it properly. If you think it's a false positive, document why the code is correct in a comment (not a phpcs:ignore comment).
